\documentclass{acm_proc_article-sp-sigmod07}

\begin{document}
\title{RESTRUCTOR: Performing queries on structurally heterogeneous
dataspaces}
\author{Sartori Enrico}
\maketitle

\begin{abstract}
This work presents a framework, called RESTRUCTOR, which permits to
perform queries on dataspaces characterized by structural heterogeneity.
The system implemented builds a relational representation of the relevant
informations contained in the dataset and uses this model for performing
queries.

The proposed model deals with differences at the structural level of the
data, but not with the different syntactic representation of semantically
equivalent attributes.

This work describes in details the model used to represent the data, and
the techniques used for the extraction of the query results from the
dataspace.
\end{abstract}

\section{INTRODUCTION}
A relevant part of the data in some particular environments as, for
example, the internet, is characterized by a lack of a structure useful
to perform queries and give a semantical meaning to the informations
handled.

In a similar environment the data are considered to be a list of
identifiers with attached a set of pairs of the form (attribute name,
value). This basilar structure can be more complex, with nested
representation of the data.

The aim of this work is to provide a system which can convert this simple
structure in a relational model which can be used for performing queries.
The main idea on which the implemented approach is based is the
realization of two different structures: one for the storage of the data
and a second, used for resolving the dependencies between attributes
discovered in the dataset.

The query task is accomplished by retrieving all the attributes linked to
the one asked, through a lookup in the attributes structure.Then the
retrieved attributes are compared with the value given, using the storage
structure.

The system implemented performs these operation by creating in a
relational database a schema which can host this model, and using this
representation for executing the queries.
The interface exposed to the user accepts a simple query language, whose
details will be presented later.

Some assumption, like the way used for identifier specification and the
language used for the implementation will be clarified in following
sections.

\section{RELATED WORK}
One of the works which covers in major details the handling with
heterogeneous datasets is \cite{kaufmann:integration}. This work gives a panoramic
view on many different cases which can be encountered in data integration.

The scope of this work is wider than the one of this paper, in fact, it
presents techniques used for solving more general problems, like syntactic
differences in the data representation models to integrate.

Anyway it presents many approaches for identifying dependencies among
attributes from different databases, these techniques can be useful even
in the case of structural differences in the same database.

This section of the work present three different groups of approaches:
semantic based, object oriented or logic based.
For each of these groups, many different approaches are presented.
The approaches which are nearer to what is the aim of this paper are the
semantical and the object oriented models.

Another important section of this work describes how to deal with the
problem of the effective generation of the integrated schema.

More close to the problem addressed in this paper is the technique
presented in \cite{dong:indexing}.
In fact this work addresses the specific problem of performing queries
over a dataspace characterized by being partially unstructured and
heterogeneous.

The solution provided by Dong and Halevy is the building of an indexing
structure, which can be used for accessing the data matching the given
query.

The indexing structure presented in the paper, is stored in form of
relational model, which permits to specify which entity owns some
particular attributes.

\section{PROBLEM STATEMENT}
As said in the introduction the aim of this work is to provide support for
performing queries over dataspaces presenting differences in the structure
used for data representation.
The system implemented doesn't deal with differences at a syntactic level,
in fact it relies on the equality of attributes name for the
identification of relations among attributes.

Possible examples of heterogeneousness in data representation that the
system can handle are in the form of the following examples:

\begin{verbatim}
entity 1
    city : molveno
    street : paganella

entity 2
    address :
        city : molveno
        street : paganella

entity 3
    address : molveno paganella 
\end{verbatim}

These three entities refers to the same real object, in fact the data
contained is semantically equivalent, but it's represented using three
different structures.

It's not possible to query directly a similar database, in fact there is
no direct correspondence between attributes from different entities.
For a human reader, is anyway clear how city and street are components of
the attribute address. This relation has to be considered when, for
example, an user asks for the entities with attribute address associated
to a specific value.

The same is valid for the inverse case, e.g. when the user asks for the
attribute city even the entities with attribute address matching the query
specification has to be returned.

The model in the previous example can be made more complex by adding a new
entity like the following:

\begin{verbatim}
entity 4
    lives:
        address :
            city : molveno
            street : paganella
    
    works:
        city : trento
         
\end{verbatim}

Adding this case a new layer of inclusion is present, in fact now city
appears as member of address, but even as component of the attribute
lives. 

It appears clear that different kind of result should have a different
weight in the final result of the query. For this reason the system
associates different ranks to entities returned in the different cases.

Obviously a higher rank is given to an entity returned in case of exact
correspondence of the name and the value of the attribute searched.
Results retrieved by looking for correspondences in the linked attributes,
instead, are ranked with a lower value.

Summarizing what said before, is possible to identify three main aspects
of the problem to solve:
\begin{itemize}
\item Insertion of the data in the relational model;
\item Performing queries on the model created;
\item Rank and organize the results;
\end{itemize}

\section{PROPOSED APPROACH}
This section of the paper presents in further details the approach
followed for giving a solution to the problem targeted. It will cover the
three aspects introduced previously.

In order to ease the implementation task is assumed that the input of the
program, the database to be analyzed, is represented by an xml file, with
no DTD attached. The root of the document is a tag entities which
contains a set of tags entity which represent an entry of the database.
Each tag entity has an unique attribute id which identifies an entry.

An example input could be the following:

\begin{verbatim}
<entities>
    <entity id="1">
        <city>trento</city>
        <street>sommarive</street>
    </entity>
</entities>
\end{verbatim}

Another possible way to represent the input could be using the JSON
syntax, which could be more appropriate than xml for representing
unstructured data. The common xml syntax has been preferred due to the
wider selection of tools for parsing and operate on this language.

The advantages in using JSON could be represented by a more lightweight
database and the use of a syntax more data-oriented, which fit better the
situation of an unstructured dataspace.

The assumption on the identifiers position in the xml has been taken for
simplifying the parsing task, and focus more attention on retrieving the
relevant information from the database. This choice doesn't influence the
accuracy of the query answering algorithm.

\subsection{Relational Model}
This section introduced the details of the structure used to store the
data and perform the queries. As said before, the data are stored in a
relational database. 

The importance of relying on a database engine for storing and handling the
data has a major importance in terms of performances. In fact a DBMS
integrates a set of optimization algorithms and caching routines which can
help maintaining the performances of the system at a good level.

The base idea of the approach followed is to extract from the database two
different kind of information. An entity in the dataspace, in fact,
contains relevant information about itself, specified by the pairs
(name, value), but it gives information even about the structure of the
data, on how different attributes relate with each other.

An example of this can be seen in the following code:

\begin{verbatim}
<entity id="1">
    <car>
        <model>punto</model>
        <brand>fiat</brand>
    </car>
</entity>
\end{verbatim}

This entity in fact contains an element car which is composed by two
different attributes, model and brand. Appears clear that exists a
relation between the attribute model and car and between brand and car.
The information that we can extract from this, about the structure of the
data, is that the attributes model and brand can appear in the dataset as
children of the attribute car.

This kind of information is vital for the query answering task, in fact,
using this prior knowledge we can return as a result for a query asking
for entities with car = fiat even the following example: 

\begin{verbatim}
<entity id="2">
    <model>punto</model>
    <brand>fiat</brand>
</entity>
\end{verbatim}

This entity doesn't refer explicitly to the car attribute, but the prior
knowledge about the structure of the dataset gives the possibility to
reach an higher accuracy for the query results.
Obviously the relevance of this entity as a result of the query car = fiat
is not the same as the one of the previous entry.

The model implemented for dealing with this kind of information is
composed by three tables. The first one is used for the storage of the
effective data, is called "pairs" and its structure is defined on three
fields:
\begin{description}
\item{pair\_id: } This is the primary key of the table, identifies a pair;
\item{name: } This field contains the name of the attribute;
\item{value: } Contains the respective value;
\end{description}

This table is populated with all the different pairs (attribute name,
attribute value) encountered reading the dataset. At each pair is
associated an unique id which is pair\_id.

The name of the attribute doesn't contain any information about its path
in the entity representation.

An important constraint set in this table is that the pairs name and value
are unique. This means that in the worst case, where there aren't
attributes with the same name and the same value among the whole database,
the table will contain a number of records equal to the number of pairs in
the original dataset.

Is likely, instead, that many entities share some pair, in this case the
shared pair will appear only one time in this table.

A second table is used for storing the information about the structure.
What is needed to be kept is some information about the position of the
attribute inside the attribute hierarchy of a specific entity.
In the model implemented the fields of this table, called "attrs" are:
\begin{description}
\item{attr\_id: } This is the primary key of the table, identifies an
attribute;
\item{name: } This field contains the name of the attribute;
\item{path: } Contains the path of the attribute from the entity node;
\end{description}

The term path doesn't refer specifically to the xml concept of path, but
in general to the attribute is nested inside some other attributes.
The same concept would work with any other representation of the dataset,
instead of xml.

Using this table is possible to reconstruct the underlying structure of
the database, and identify every different attribute present in the
dataset.

Is important to notice that this table contains only the attributes which,
appear at least one time in the database with a value associated.
If an attribute appears only as parent of other attributes in the whole
dataset, it won't appear in this table.

Even in this case the path is an unique field, so attributes with
identical structure will appear only one time in the table.

The last table permits to combine the information in the previous two
tables.
In fact the third table, called "associations" contains the following
fields:
\begin{description}
\item{entity\_id: } This fields contain the id of the entity which owns
the pair;
\item{pair\_id: } This is the id of the pair owned, refers to the pairs
table;
\item{attr\_id: } Indicates which particular attribute forms the pair,
refers to the attrs table;
\end{description}

This table links the information on the data with the knowledge about the
structure. Is therefore possible to know exactly the particular attributes
which form every pair of an entity, and the associated value.

This is the table which present the larger number of records of the three,
in fact it will contain one row for each pair encountered in the dataset.

\subsection{Query language}
Before going in further details about the query answering techniques, is
useful to specify the query languages used to interact with the system.

\bibliographystyle{abbrv}
\bibliography{report}
\end{document}
